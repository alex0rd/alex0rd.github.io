[{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/categories/android%E9%80%86%E5%90%91/","section":"Categories","summary":"","title":"Android逆向","type":"categories"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/tags/unidbg/","section":"Tags","summary":"","title":"Unidbg","type":"tags"},{"content":" 主要是对龙哥Unidbg教程学习的笔记\nUnidbg 中处理文件访问（一）\n1. 补文件访问的方式 # 1.1 方式一：创建文件处理对象 # addIOResolver用于添加一个文件处理器对象，将如下代码放在早于 loadlibrary 的时机即可生效。\nemulator.getSyscallHandler().addIOResolver(new IOResolver\u0026lt;AndroidFileIO\u0026gt;() { @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; resolve(Emulator\u0026lt;AndroidFileIO\u0026gt; emulator, String pathname, int oflags) { System.out.println(\u0026#34;file open:\u0026#34;+pathname); return null; } }); 1.2 方式二：实现IOResolver接口 # 让目标类实现 IOResolver 接口，那么就是addIOResolver(this)。\n... public class Bili extends AbstractJni implements IOResolver\u0026lt;AndroidFileIO\u0026gt;{ ... public Bili(){ emulator.getSyscallHandler().addIOResolver(this); } @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; resolve(Emulator\u0026lt;AndroidFileIO\u0026gt; emulator, String pathname, int oflags) { System.out.println(\u0026#34;file open:\u0026#34;+pathname); return null; } ... } 在处理很复杂的样本时，我们希望逻辑分离，那么可以把 IOResolver 从主类中摘出去。\n... public class BiliIOResolver implements IOResolver\u0026lt;AndroidFileIO\u0026gt; { @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; resolve(Emulator\u0026lt;AndroidFileIO\u0026gt; emulator, String pathname, int oflags) { System.out.println(\u0026#34;file open:\u0026#34;+pathname); return null; } } ... 再在主类中调用addIOResolver(new BiliIOResolver())即可\nemulator.getSyscallHandler().addIOResolver(new BiliIOResolver()); 添加多个自定义文件处理器的场景里（比如处理某公司旗下的多个样本，它们在多数文件访问上类似，但少部分需要各自处理。），需要注意后添加的优先级更高。\nemulator.getSyscallHandler().addIOResolver(new IOResolver\u0026lt;AndroidFileIO\u0026gt;() { @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; resolve(Emulator\u0026lt;AndroidFileIO\u0026gt; emulator, String pathname, int oflags) { System.out.println(\u0026#34;Resolver A\u0026#34;); return null; } }); emulator.getSyscallHandler().addIOResolver(new IOResolver\u0026lt;AndroidFileIO\u0026gt;() { @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; resolve(Emulator\u0026lt;AndroidFileIO\u0026gt; emulator, String pathname, int oflags) { System.out.println(\u0026#34;Resolver B\u0026#34;); return null; } }); 2. 基本文件访问处理 # 2. 1 基本流程 # 例如：\nemulator.getSyscallHandler().addIOResolver(new IOResolver\u0026lt;AndroidFileIO\u0026gt;() { @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; resolve(Emulator\u0026lt;AndroidFileIO\u0026gt; emulator, String pathname, int oflags) { //参数二: 文件路径 //参数三: 操作文件标志 switch (pathname){ case \u0026#34;/proc/sys/kernel/random/boot_id\u0026#34;:{ return FileResult.\u0026lt;AndroidFileIO\u0026gt;success(new SimpleFileIO(oflags, new File(\u0026#34;unidbg-android/src/test/resources/dewu/cpu/boot_id\u0026#34;), pathname)); } } return null; } }); 最外层是FileResult.\u0026lt;AndroidFileIO\u0026gt;success，我们可以返回任意 AndroidFileIO 类型的文件，这么说有点怪，这是因为 Unidbg 是一个 Android/IOS 双端的 Native 模拟器，除了 AndroidFileIO 还有对应于 IOS 的 DarwinFileIO，所以有此限制。 对文件访问有 success、failed、fallback 三种处理\nsuccess 表示文件顺利访问，参数是 NewFileIO。 failed 表示文件访问失败，参数是 erron 错误码。 fallback 表示回退、降级，只有在其他处理器无法处理对该文件的访问时，才由 fallback 指定的文件 IO 来处理 2.2 单个文件 # 对于单个文件，常用的API有SimpleFileIO和ByteArrayFileIO。 上面那段代码就是使用的SimpleFIleIO，ByteArrayFileIO 在 oflags、pathname 上和 SimpleFileIO 无差别，但它接收一个字节数组而非 File 文件，对于灵活补文件内容有很大的帮助。\nemulator.getSyscallHandler().addIOResolver(new IOResolver\u0026lt;AndroidFileIO\u0026gt;() { @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; resolve(Emulator\u0026lt;AndroidFileIO\u0026gt; emulator, String pathname, int oflags) { System.out.println(\u0026#34;Resolver A\u0026#34;); switch (pathname){ case \u0026#34;/proc/sys/kernel/random/boot_id\u0026#34;:{ return FileResult.\u0026lt;AndroidFileIO\u0026gt;success(new ByteArrayFileIO(oflags, pathname, UUID.randomUUID().toString().getBytes(StandardCharsets.UTF_8))); } } return null; } }); 它的副作用——没办法做文件做写入操作，ByteArrayFileIO 像浮萍漂泊，无根无依。\n@Override public int write(byte[] data) { throw new UnsupportedOperationException(); } 2.3 目录 # 如果样本访问的是目录，也有两种操作方式。一种是通过DirectoryFileIO，另一种是虚拟文件系统。\ncase \u0026#34;/data/data/com.sankuai.meituan\u0026#34;:{ return FileResult.\u0026lt;AndroidFileIO\u0026gt;success(new DirectoryFileIO(oflags, pathname, new File(\u0026#34;unidbg-android/src/test/resources/meituan/data\u0026#34;))); } 但对于文件夹访问而言，使用虚拟文件系统是更好的选择。通过setRootDir设置target/rootfs为根目录，之后再将待处理的文件按照层级放到对应位置。\nAndroidEmulatorBuilder.setRootDir(new File(\u0026#34;target/rootfs\u0026#34;)) 2.5 特殊处理 # 对于文件访问失败（failed），一般是不用管的。但是存在一种情况，如果文件访问 /data，判断是否有写权限，进而确认设备环境是否 Root 的话，我们需要手动处理。\ncase \u0026#34;/data\u0026#34;:{ return FileResult.failed(UnixEmulator.EACCES); } 3. 环境检测 # 当样本做环境检测相关的文件访问时，主要检测这些文件是否存在，以及是否有权限\nRoot检测（检测 su、Magisk、Riru，检测市面上的 Root 工具） 模拟器检测（检测 Qemu，检测各家模拟器，比如夜神、雷电、Mumu 等模拟器的文件特征、驱动特征等） 危险应用检测（各类多开助手、按键精灵、接码平台等） 云手机检测 （以各种云手机产品为主） Hook框架（以 Xposed、Substrate、Frida 为主） 脱壳机（以 Fart、DexHunter、Youpk 三者为主） 我们选择什么都不补就行，因为不管是自定义还是默认的文件处理器，以及虚拟文件系统里，都不会有这样内容，所以什么就不补就好了。\n4. proc 伪文件系统 # proc 是一个由内核动态创建和生成的目录，程序通过访问它，获取各种各样的内核信息。\n访问频率高——文件访问中最高频处理的目录 容易出错——尽管整体上的处理和普通文件一样，但局部要特殊处理。 4.1 cmdline # /proc/self(pid)/cmdline 用于查看自身进程名，常用于信息收集或检测运行环境是否有异。 结尾记得加上\\0，这是 cmdline 的格式规范，不加的话在解析时存在出错的可能性。\n// A if ((\u0026#34;/proc/\u0026#34;+emulator.getPid()+\u0026#34;/cmdline\u0026#34;).equals(pathname) || (\u0026#34;/proc/self/cmdline\u0026#34;).equals(pathname)) { // 具体处理逻辑 } // B if (pathname.contains(\u0026#34;cmdline\u0026#34;)) { // 具体处理逻辑 } // 查看当前进程名 if ((\u0026#34;/proc/\u0026#34;+emulator.getPid()+\u0026#34;/cmdline\u0026#34;).equals(pathname) || (\u0026#34;/proc/self/cmdline\u0026#34;).equals(pathname)) { return FileResult.success(new ByteArrayFileIO(oflags, pathname, \u0026#34;name\\0\u0026#34;.getBytes())); } 4.2 status # /proc/self(pid)/status 最主要用来检测 tracepid 状态。 偷懒补法：\nif ((\u0026#34;proc/\u0026#34; + emulator.getPid() + \u0026#34;/status\u0026#34;).equals(pathname)) { return FileResult.success(new ByteArrayFileIO(oflags, pathname, (\u0026#34;TracerPid: 0\u0026#34;).getBytes())); } 规范补法：\nif(pathname.equals(\u0026#34;proc/\u0026#34;+emulator.getPid()+\u0026#34;/status\u0026#34;)){ return FileResult.success(new ByteArrayFileIO(oflags, pathname, (\u0026#34;Name: ip.android.view\\n\u0026#34; + \u0026#34;Umask: 0077\\n\u0026#34; + \u0026#34;State: S (sleeping)\\n\u0026#34; + \u0026#34;Tgid: \u0026#34;+emulator.getPid()+\u0026#34;\\n\u0026#34; + \u0026#34;Ngid: 0\\n\u0026#34; + \u0026#34;Pid: \u0026#34;+emulator.getPid()+\u0026#34;\\n\u0026#34; + \u0026#34;PPid: 6119\\n\u0026#34; + \u0026#34;TracerPid: 0\\n\u0026#34; + \u0026#34;Uid: 10494 10494 10494 10494\\n\u0026#34; + \u0026#34;Gid: 10494 10494 10494 10494\\n\u0026#34; + \u0026#34;FDSize: 512\\n\u0026#34; + \u0026#34;Groups: 3002 3003 9997 20494 50494 99909997\\n\u0026#34; + \u0026#34;VmPeak: 2543892 kB\\n\u0026#34; + \u0026#34;VmSize: 2466524 kB\\n\u0026#34; + \u0026#34;VmLck: 0 kB\\n\u0026#34; + \u0026#34;VmPin: 0 kB\\n\u0026#34; + \u0026#34;VmHWM: 475128 kB\\n\u0026#34; + \u0026#34;VmRSS: 415548 kB\\n\u0026#34; + \u0026#34;RssAnon: 144072 kB\\n\u0026#34; + \u0026#34;RssFile: 267216 kB\\n\u0026#34; + \u0026#34;RssShmem: 4260 kB\\n\u0026#34; + \u0026#34;VmData: 1488008 kB\\n\u0026#34; + \u0026#34;VmStk: 8192 kB\\n\u0026#34; + \u0026#34;VmExe: 20 kB\\n\u0026#34; + \u0026#34;VmLib: 239368 kB\\n\u0026#34; + \u0026#34;VmPTE: 2360 kB\\n\u0026#34; + \u0026#34;VmPMD: 16 kB\\n\u0026#34; + \u0026#34;VmSwap: 13708 kB\\n\u0026#34; + \u0026#34;Threads: 122\\n\u0026#34; + \u0026#34;SigQ: 0/21555\\n\u0026#34; + \u0026#34;SigPnd: 0000000000000000\\n\u0026#34; + \u0026#34;ShdPnd: 0000000000000000\\n\u0026#34; + \u0026#34;SigBlk: 0000000080001204\\n\u0026#34; + \u0026#34;SigIgn: 0000000000000001\\n\u0026#34; + \u0026#34;SigCgt: 0000000e400096fc\\n\u0026#34; + \u0026#34;CapInh: 0000000000000000\\n\u0026#34; + \u0026#34;CapPrm: 0000000000000000\\n\u0026#34; + \u0026#34;CapEff: 0000000000000000\\n\u0026#34; + \u0026#34;CapBnd: 0000000000000000\\n\u0026#34; + \u0026#34;CapAmb: 0000000000000000\\n\u0026#34; + \u0026#34;Seccomp: 2\\n\u0026#34; + \u0026#34;Speculation_Store_Bypass: unknown\\n\u0026#34; + \u0026#34;Cpus_allowed: 07\\n\u0026#34; + \u0026#34;Cpus_allowed_list: 0-2\\n\u0026#34; + \u0026#34;Mems_allowed: 1\\n\u0026#34; + \u0026#34;Mems_allowed_list: 0\\n\u0026#34; + \u0026#34;voluntary_ctxt_switches: 17290\\n\u0026#34; + \u0026#34;nonvoluntary_ctxt_switches: 10433\u0026#34;).getBytes(StandardCharsets.UTF_8))); } 4.3 net # /proc/net 下的文件一律不要补，有两个理由。\n一是 Goolg 禁止普通进程访问该目录，这一规定对 Android 10 以及更高的版本均有效，所以我们伪装成高版本，多一事不如少一事，少补几个文件而且无副作用，岂不美哉。\n二是这个目录主要用于检测环境，比如 IDA/Frida Server 的端口检测。将真机的对应文件一股脑 拷贝过来，还可能把风险信息和检测点带过来。\n常见文件： /proc/net/arp /proc/net/tcp /proc/net/unix\n4.4 信息获取 # 遇到下面这些文件时，建议正常补，并且了解每个文件的用途，在生产环境上部分需要随机化。\n/proc/meminfo /proc/version /proc/cpuinfo /proc/stat /proc/asound/cardX/id /proc/self/exe\n4.5 maps # /proc/self(pid)/maps 是补 proc 文件访问中最重要的一项，因为 maps 访问频率高以及地位特殊，Unidbg 中对它做了专门的处理——如果在自定义 IOResolver 中没有得到处理，会在最后的虚拟文件系统这一块进行如下处理\n// src/main/java/com/github/unidbg/file/linux/LinuxFileSystem.java @Override public FileResult\u0026lt;AndroidFileIO\u0026gt; open(String pathname, int oflags) { if (\u0026#34;/proc/self/maps\u0026#34;.equals(pathname) || (\u0026#34;/proc/\u0026#34; + emulator.getPid() + \u0026#34;/maps\u0026#34;).equals(pathname)) { return FileResult.\u0026lt;AndroidFileIO\u0026gt;success(new MapsFileIO(oflags, pathname, emulator.getMemory().getLoadedModules())); } return super.open(pathname, oflags); } MapsFileIO 是 Unidbg 所设计的 fakemaps，它反应了 Unidbg 内存环境中的模块信息，即在语义和格式都等价于真实 maps。 从客观上讲，这个 maps 确实能处理一些问题。比如样本访问 maps，检测其中是否有 frida / xposed / substrate / magisk / riru 等风险模块，真实 maps 会暴露这些信息，而 Unidbg fakeMaps 很干净、简洁，所以不会有任何问题。 fakeMaps 仅包含按目标模块极其依赖的信息，真实 maps 包含整个进程所涉及的所有模块的信息，因此在内容上，fakeMaps 是 真实 maps 的子集，后者包含了许多前者不具备的信息。 当代码试图访问fakemap不包含的信息，比如maps中特定的加载文件，当前进程所对应的apk等，使用fakemaps就会出问题。 遇到对 maps 的访问，就对这部分逻辑做算法分析，完全确定其访问意图，然后反向构造合适的 maps 予以返回。\n在实践上，可能没法总这么干，因为太费事了，那么建议优先使用真实 maps，如果出现内存异常（这意味着样本在基于真实 maps 做内存访问），就使用 fakemaps。\n","date":"8 January 2025","externalUrl":null,"permalink":"/posts/2025m1d8h3m37s35/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e主要是对龙哥Unidbg教程学习的笔记\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/lfssh8/euffrv?#%20%E3%80%8AUnidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%8B\" target=\"_blank\"\u003eUnidbg 中处理文件访问（一）\u003c/a\u003e\u003c/p\u003e","title":"Unidbg补环境之处理文件访问","type":"posts"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/tags/%E7%AC%94%E8%AE%B0/","section":"Tags","summary":"","title":"笔记","type":"tags"},{"content":" 主要是对龙哥Unidbg教程学习的笔记\nUnidbg 的基本使用（三）\nUnidbg 的基本使用（四）\nUnidbg 的基本使用（五）\nUnidbg 的基本使用（六）\nUnidbg 的基本使用（七）\nUnidbg 的基本使用（八）\nUnidbg 的基本使用（九）\n1. 形式处理 # 也就是对数据的包装，在值传递过程种可能会遇见这类问题。\n基本类型直接传递 字符串、字节数组等基本对象直接传递，其内部会做封装，也可以自己调用new StringObject(vm, str)、new ByteArray(vm, value)等。 JDK 标准库对象，如 HashMap、JSONObject 等，使用ProxyDvmObject.createObject(vm, value)处理。 非 JDK 标准库对象，如 Android Context、SharedPreference 等，使用vm.resolveClass(vm，className).newObject(value)处理 1.1 基本数据类型处理 # 基本数据类型，即：byte、short、int、long、double、float、boolean、char。他们直接传递即可。但Long类型必须显示声明，即在整数后面加L，以供 Unidbg 识别和处理。\n1.2 字符串\u0026amp;基本类型包装类\u0026amp;数组 # 字符串、基本类型的包装类、、基本类型数组、对象类型数组等。\n1. 字符串 # 对于String类型的数据，需要将其处理为StringObject\n//java.lang.UnsupportedOperationException: cn/xiaochuankeji/tieba/AppController-\u0026gt;getPackageName()Ljava/lang/String; //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416) //\tat com.izuiyou.NetWork.callObjectMethodV(NetWork.java:86) //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262) StringObject stringObject1 = (StringObject) ProxyDvmObject.createObject(vm, str); StringObject stringObject2 = new StringObject(vm, str); // 更推荐 2. 基本类型的包装类 # Unidbg中对部分包装类进行处理，在com.github.unidbg.linux.android.dvm.wrapper文件夹下：DvmBoolean.java、DvmInteger.java、DvmLong.java 其中都提供了valueOf方法做包装 例如对Integer处理：\n//java.lang.UnsupportedOperationException: java/lang/Integer-\u0026gt;\u0026lt;init\u0026gt;(I)V //\tat com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:789) //\tat com.demo5.MeiTuan.newObjectV(MeiTuan.java:557) case \u0026#34;java/lang/Integer-\u0026gt;\u0026lt;init\u0026gt;(I)V\u0026#34;: { int i = vaList.getIntArg(0); return DvmInteger.valueOf(vm, i); } 3. 基本类型数组 # 有两种处理方式： 一、com.github.unidbg.linux.android.dvm.array包下有对各种基本类型数组的表示和处理。 JNI数组类型Unidbg中对应关系\nJNI Unidbg jarray BaseArray jobjectArray ArrayObject jbyteArray ByteArray jdoubleArray DoubleArray jfloatArray FloatArray jIntArray IntArray jshotArray ShortArray 二、使用ProxyDvmObject.createObject。其内部会做对应的处理 if (value instanceof byte[]) { return new ByteArray(vm, (byte[]) value); } if (value instanceof short[]) { return new ShortArray(vm, (short[]) value); } if (value instanceof int[]) { return new IntArray(vm, (int[]) value); } if (value instanceof float[]) { return new FloatArray(vm, (float[]) value); } if (value instanceof double[]) { return new DoubleArray(vm, (double[]) value); } 例如对[B，即字节数组进行处理\n//java.lang.UnsupportedOperationException: java/net/NetworkInterface-\u0026gt;getHardwareAddress()[B //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethod(AbstractJni.java:921) //\tat com.demo14.SimpleSign.callObjectMethod(SimpleSign.java:177) case \u0026#34;java/net/NetworkInterface-\u0026gt;getHardwareAddress()[B\u0026#34;: byte[] addr = new byte[]{0x64, (byte) 0xBC, 0x0C, 0x65, (byte) 0xAA, 0x1E}; // return (ByteArray) ProxyDvmObject.createObject(vm, addr) //也可以 return new ByteArray(vm, addr); 4 . 对象数组 # 有两种处理方式：一种方式是通过ProxyDvmObject.createObject，其最终还是通过ArrayObject来处理。另一种方式是直接使用ArrayObject 在 Unidbg 中，对象数组通过ArrayObject表示，而且还为字符串数组提供了一个方便的处理函数。\npublic static ArrayObject newStringArray(VM vm, String... strings) { StringObject[] objects = new StringObject[strings.length]; for (int i = 0; i \u0026lt; strings.length; i++) { String str = strings[i]; if (str != null) { objects[i] = new StringObject(vm, str); } } return new ArrayObject(objects); } 使用它可以方便的构造字符串数组：\n//java.lang.UnsupportedOperationException: android/os/Build-\u0026gt;SUPPORTED_ABIS:[Ljava/lang/String; //\tat com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103) //\tat com.demo5.MeiTuan.getStaticObjectField(MeiTuan.java:629) case \u0026#34;android/os/Build-\u0026gt;SUPPORTED_ABIS:[Ljava/lang/String;\u0026#34;:{ return ArrayObject.newStringArray(vm, \u0026#34;arm64-v8a\u0026#34;, \u0026#34;armeabi-v7a\u0026#34;, \u0026#34;armeabi\u0026#34;); } 也可以使用ProxyDvmObject.createObject\ncase \u0026#34;android/os/Build-\u0026gt;SUPPORTED_ABIS:[Ljava/lang/String;\u0026#34;:{ String[] abis = new String[]{\u0026#34;arm64-v8a\u0026#34;, \u0026#34;armeabi-v7a\u0026#34;, \u0026#34;armeabi\u0026#34;}; return ProxyDvmObject.createObject(vm, abis); } 5. List # 使用ArrayListObject, 参考：\n//java.lang.UnsupportedOperationException: android/hardware/SensorManager-\u0026gt;getSensorList(I)Ljava/util/List; //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416) //\tat com.demo2.Tiny.callObjectMethodV(Tiny.java:334) case \u0026#34;android/hardware/SensorManager-\u0026gt;getSensorList(I)Ljava/util/List;\u0026#34;:{ int length = 10; List\u0026lt;DvmObject\u0026lt;?\u0026gt;\u0026gt; SensorList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; length; i++) { SensorList.add(vm.resolveClass(\u0026#34;android/hardware/Sensor\u0026#34;).newObject(i)); } return new ArrayListObject(vm, SensorList); } 1.3 JDK 标准库 # 基本只能使用ProxyDvmObject.createObject来处理了\n1. HashMap # // java.lang.UnsupportedOperationException: java/util/HashMap-\u0026gt;\u0026lt;init\u0026gt;()V //\tat com.github.unidbg.linux.android.dvm.AbstractJni.newObject(AbstractJni.java:741) //\tat com.demo4.TBSecurity.newObject(TBSecurity.java:392) case \u0026#34;java/util/HashMap-\u0026gt;\u0026lt;init\u0026gt;()V\u0026#34;:{ return ProxyDvmObject.createObject(vm, new HashMap\u0026lt;\u0026gt;()); } 2. InputStream # //java.lang.UnsupportedOperationException: java/util/zip/ZipFile-\u0026gt;getInputStream(Ljava/util/zip/ZipEntry;)Ljava/io/InputStream; //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416) //\tat com.demo7.TDJNI.callObjectMethodV(TDJNI.java:625) case \u0026#34;java/util/zip/ZipFile-\u0026gt;getInputStream(Ljava/util/zip/ZipEntry;)Ljava/io/InputStream;\u0026#34;:{ ZipFile zipFile = (ZipFile) dvmObject.getValue(); try { return ProxyDvmObject.createObject(vm, zipFile.getInputStream((ZipEntry) vaList.getObjectArg(0).getValue())); } catch (IOException e) { e.printStackTrace(); } } 5. Object类型 # //java.lang.UnsupportedOperationException: java/util/Map-\u0026gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object; //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethod(AbstractJni.java:922) //\tat com.Bili.NativeLibrary.callObjectMethod(NativeLibrary.java:88) case \u0026#34;java/util/Map-\u0026gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\u0026#34;:{ Map map = (Map) dvmObject.getValue(); Object key = varArg.getObjectArg(0).getValue(); Object value = varArg.getObjectArg(1).getValue(); return ProxyDvmObject.createObject(vm, map.put(key, value)); } 1.4 Android FrameWork 类库 # 对于 Android FrameWork 类库中的对象和类，使用resolveClass创建对应的DvmClass和DvmObject比较好。在 AbstrctJNI 中可以看到大量的例子。\n例一 # //java.lang.UnsupportedOperationException: android/telephony/FtTelephonyAdapter-\u0026gt;getFtTelephony(Landroid/content/Context;)Landroid/telephony/FtTelephony; //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:503) //\tat com.demo7.TDJNI.callStaticObjectMethodV(TDJNI.java:763) case \u0026#34;android/telephony/FtTelephonyAdapter-\u0026gt;getFtTelephony(Landroid/content/Context;)Landroid/telephony/FtTelephony;\u0026#34;:{ return vm.resolveClass(\u0026#34;android/telephony/FtTelephony\u0026#34;).newObject(null); } 例二 # Class.forName(className)用于加载类，我们不确定所加载的类是样本自定义的类、Android 框架层类库，还是 JDK 中的标准类库，这种情况里使用resolveClass是好办法。\n//java.lang.UnsupportedOperationException: java/lang/Class-\u0026gt;forName(Ljava/lang/String;)Ljava/lang/Class; //\tat com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:503) //\tat com.demo7.TDJNI.callStaticObjectMethodV(TDJNI.java:763) case \u0026#34;java/lang/Class-\u0026gt;forName(Ljava/lang/String;)Ljava/lang/Class;\u0026#34;:{ String className = vaList.getObjectArg(0).getValue().toString(); System.out.println(\u0026#34;Class-\u0026gt;forName:\u0026#34;+className); return vm.resolveClass(className); } ```### 例三： 这里要初始化`IntentFilter`，同样的 Android 框架层的类库，只能做占位处理。 ```Java //java.lang.UnsupportedOperationException: android/content/IntentFilter-\u0026gt;\u0026lt;init\u0026gt;(Ljava/lang/String;)V //\tat com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:791) //\tat com.demo7.TDJNI.newObjectV(TDJNI.java:826) case \u0026#34;android/content/IntentFilter-\u0026gt;\u0026lt;init\u0026gt;(Ljava/lang/String;)V\u0026#34;:{ String intent = vaList.getObjectArg(0).getValue().toString(); System.out.println(\u0026#34;IntentFilter:\u0026#34;+intent); return vm.resolveClass(\u0026#34;android/content/IntentFilter\u0026#34;).newObject(intent); } 2. 内容处理 # 2.1 数据获取 # 方法一：理解代码 # 理解方法、字段的语义，返回合适的值。 例如：isVpn函数，是检测VPN的函数，通过google了解函数含义，返回合适的值。\n// 检测 VPN，通过 tun0/ppp0。 case \u0026#34;com/meituan/android/common/mtguard/NBridge$SIUACollector-\u0026gt;isVPN()Ljava/lang/String;\u0026#34;:{ return new StringObject(vm, \u0026#34;0\u0026#34;); } 方法二：adb命令 # ADB命令 例如：获取屏幕宽高，通过ADB获取信息，然后再返回。\n// adb shell wm size // Physical size: 1080x2160 case \u0026#34;android/view/Display-\u0026gt;getHeight()I\u0026#34;:{ return 2160; } case \u0026#34;android/view/Display-\u0026gt;getWidth()I\u0026#34;:{ return 1080; } 方法三：自写demo获取 # 自写demo，做验证。 例如：获取传感器信息\n//SensorManager manager= (SensorManager)getSystemService(SENSOR_SERVICE); //Sensor accelSensor = manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); //Log.e(\u0026#34;lilac sensor Name\u0026#34;,accelSensor.getName()); // lilac sensor Name: ICM20690 case \u0026#34;android/hardware/Sensor-\u0026gt;getName()Ljava/lang/String;\u0026#34;:{ int type = (int) dvmObject.getValue(); System.out.println(\u0026#34;Sensor getName:\u0026#34;+type); if(type == 1){ return new StringObject(vm, \u0026#34;ICM20690\u0026#34;); }else { throw new UnsupportedOperationException(signature); } } 方法四：frida hook\u0026amp;call # Unidbg 补的执行流在真机上也理应执行过，那么 Frida Spwan 模式 Hook 应该能拦截到这种例如：uiAutomatorClickCount的处理就依赖于 Hook。 frida hook\nJava.perform(function() { let SIUACollector = Java.use(\u0026#34;com.meituan.android.common.mtguard.NBridge$SIUACollector\u0026#34;); SIUACollector[\u0026#34;uiAutomatorClickCount\u0026#34;].implementation = function () { console.log(\u0026#39;uiAutomatorClickCount is called\u0026#39;); let ret = this.uiAutomatorClickCount(); console.log(\u0026#39;uiAutomatorClickCount ret value is \u0026#39; + ret); return ret; }; }) // uiAutomatorClickCount ret value is 0 Unidbg处理\n@Override public int callIntMethodV(BaseVM vm, DvmObject\u0026lt;?\u0026gt; dvmObject, String signature, VaList vaList) { switch (signature){ case \u0026#34;com/meituan/android/common/mtguard/NBridge$SIUACollector-\u0026gt;uiAutomatorClickCount()I\u0026#34;:{ return 0; } } return super.callIntMethodV(vm, dvmObject, signature, vaList); } 方法五：trace # 例如使用r0trace 追踪SIUACollector类里的所有事件。\n//A. 简易trace单个函数 traceClass(\u0026#34;com.meituan.android.common.mtguard.NBridge$SIUACollector\u0026#34;) 在输出日志中可以找到字段的多次赋值过程\nint level =\u0026gt; 3 =\u0026gt; 3 boolean plugged =\u0026gt; false =\u0026gt; false int scale =\u0026gt; 100 =\u0026gt; 100 int status =\u0026gt; 0 =\u0026gt; 0 trace 是最快的补环境办法。 trace工具： 1. r0tracer 2. JNITrace 3. JTrace\n2.2 代码逻辑 # 处理一：JDK/第三方库代码 # 对于 JDK 里包含的类库，可以直接复现其方法逻辑。 比如对 SimpleDateFormat 的操作\ncase \u0026#34;java/text/SimpleDateFormat-\u0026gt;\u0026lt;init\u0026gt;(Ljava/lang/String;Ljava/util/Locale;)V\u0026#34;:{ String pattern = vaList.getObjectArg(0).getValue().toString(); Locale locale = (Locale) vaList.getObjectArg(1).getValue(); simpleDateFormat = new SimpleDateFormat(pattern, locale); return; } 比如 okhttp3，可以 maven 引入然后正常使用\ncase \u0026#34;okhttp3/Headers-\u0026gt;name(I)Ljava/lang/String;\u0026#34;:{ Headers headers = (Headers) dvmObject.getValue(); return new StringObject(vm, headers.name(vaList.getIntArg(0))); } case \u0026#34;okhttp3/Headers-\u0026gt;value(I)Ljava/lang/String;\u0026#34;:{ Headers headers = (Headers) dvmObject.getValue(); return new StringObject(vm, headers.value(vaList.getIntArg(0))); } case \u0026#34;okio/Buffer-\u0026gt;clone()Lokio/Buffer;\u0026#34;:{ Buffer buffer = (Buffer) dvmObject.getValue(); return vm.resolveClass(\u0026#34;okio/Buffer\u0026#34;).newObject(buffer.clone()); } case \u0026#34;okhttp3/Request-\u0026gt;newBuilder()Lokhttp3/Request$Builder;\u0026#34;: { Request request = (Request) dvmObject.getValue(); return vm.resolveClass(\u0026#34;okhttp3/Request$Builder\u0026#34;).newObject(request.newBuilder()); } case \u0026#34;okhttp3/Request$Builder-\u0026gt;header(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;\u0026#34;: { Request.Builder builder = (Request.Builder) dvmObject.getValue(); builder.header(vaList.getObjectArg(0).getValue().toString(), vaList.getObjectArg(1).getValue().toString()); return dvmObject; } case \u0026#34;okhttp3/Request$Builder-\u0026gt;build()Lokhttp3/Request;\u0026#34;: { Request.Builder builder = (Request.Builder) dvmObject.getValue(); request = builder.build(); return vm.resolveClass(\u0026#34;okhttp3/Request\u0026#34;).newObject(request); } 处理二：自身代码 # 样本自定义的类库，可以在JADX、GDA、JEB等工具中反编译，然后把代码逻辑拷贝到 Unidbg 环境里。有些 Android FrameWork 层的类库也同样可以拷贝过来。 例如Android 的 Base64 工具类，可以直接抠出来\ncase \u0026#34;android/util/Base64-\u0026gt;decode(Ljava/lang/String;I)[B\u0026#34;:{ String arg = vaList.getObjectArg(0).getValue().toString(); int flag = vaList.getIntArg(1); return new ByteArray(vm, Base64.decode(arg, flag)); } 处理三：Android FrameWork类库 # 有些 Android FrameWork 类库，使用频率很高，JDK 里又没有其对应，我们就需要复写其语义，实现其基本功能。 比如 SharedPreferences，我们最好写一个小的 demo，实现 Android 中对 SP 的创建、打开、读取、修改、保存这些基本功能。\nimport com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import java.io.*; public class SharedPreferences { private JSONObject jsonObject; private final File mFile; SharedPreferences(File file) { mFile = file; jsonObject = null; loadFromDisk(); } private void loadFromDisk() { if (mFile.exists() \u0026amp;\u0026amp; !mFile.canRead()) { System.out.println(\u0026#34;Attempt to read preferences file \u0026#34; + mFile + \u0026#34; without permission\u0026#34;); } BufferedInputStream str; try { str = new BufferedInputStream(new FileInputStream(mFile), 16 * 1024); readSP(str); } catch (Exception e) { System.out.println(\u0026#34;getSharedPreferences:\u0026#34; + e); } } public String getString(String key, String defValue) { String v = (String)jsonObject.get(key); return v != null ? v : defValue; } public void putString(String key, String value){ jsonObject.put(key, value); } private void readSP(InputStream in){ char[] buf = new char[16 * 1024]; InputStreamReader input; try { input = new InputStreamReader(in); int len =input.read(buf); String text =new String(buf,0, len); jsonObject = JSON.parseObject(text); } catch (IOException e) { e.printStackTrace(); } } } 以及根据样本所操作的属性和方法，构建对应的类去描述它\npublic class AccessibilityServiceInfo { // 指定您希望服务处理的无障碍事件所属的应用的软件包名称。如果省略此参数，则无障碍服务会被视为可用于处理任何应用的无障碍事件。 // 即当前无障碍服务作用于哪些app public String[] packageNames; // 当前无障碍服务的名称 public String name; // 当前无障碍服务所属App的标签名 public CharSequence label; // 当前无障碍服务所属App的包名 public String packageName; public AccessibilityServiceInfo(String packageName, String name, CharSequence label, String[] packageNames){ this.packageName = packageName; this.name = name; this.label = label; this.packageNames = packageNames; } } 处理四：处理不了或很麻烦的代码 # 如果其他方法处理不了或者很麻烦，我们会将方法调用”降级“为简单的数据返回或占位或返回 null，这么做有风险，但总比没法继续执行好。\ncase \u0026#34;android/bluetooth/BluetoothAdapter-\u0026gt;getDefaultAdapter()Landroid/bluetooth/BluetoothAdapter;\u0026#34;:{ return dvmClass.newObject(signature); } case \u0026#34;android/telephony/SubscriptionManager-\u0026gt;from(Landroid/content/Context;)Landroid/telephony/SubscriptionManager;\u0026#34;:{ return dvmClass.newObject(signature); } case \u0026#34;android/net/Uri-\u0026gt;parse(Ljava/lang/String;)Landroid/net/Uri;\u0026#34;:{ String key = vaList.getObjectArg(0).getValue().toString(); if(key.equals(\u0026#34;content://telephony/siminfo\u0026#34;)){ return dvmClass.newObject(key); } } 例如\n// 获取packageName信息，后续对比是否有多开助手类app // https://blog.csdn.net/qq_32227681/article/details/110563688 case \u0026#34;android/content/pm/PackageManager-\u0026gt;getInstalledPackages(I)Ljava/util/List;\u0026#34;:{ return null; } ","date":"7 January 2025","externalUrl":null,"permalink":"/posts/2025m1d7h22m24s55/","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e主要是对龙哥Unidbg教程学习的笔记\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/xdwlsg/bmf8lm68ffvhrfu0?#QGrRF\" target=\"_blank\"\u003eUnidbg 的基本使用（三）\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/xdwlsg/uo6guvore38kr29y?#YwXpE\" target=\"_blank\"\u003eUnidbg 的基本使用（四）\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/xdwlsg/hiiaukxvr2zuz5mb?#%20%E3%80%8AUnidbg%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%8B\" target=\"_blank\"\u003eUnidbg 的基本使用（五）\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/xdwlsg/avlc01hrko6yvr26?#%20%E3%80%8AUnidbg%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%8B\" target=\"_blank\"\u003eUnidbg 的基本使用（六）\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/xdwlsg/ybo3xo4kloaqc1xq?#%20%E3%80%8AUnidbg%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%8B\" target=\"_blank\"\u003eUnidbg 的基本使用（七）\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/xdwlsg/td2t5cvohdedb878?#%20%E3%80%8AUnidbg%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E5%85%AB%EF%BC%89%E3%80%8B\" target=\"_blank\"\u003eUnidbg 的基本使用（八）\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://www.yuque.com/lilac-2hqvv/xdwlsg/nwqez8c4hm5hri8c?#%20%E3%80%8AUnidbg%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B9%9D%EF%BC%89%E3%80%8B\" target=\"_blank\"\u003eUnidbg 的基本使用（九）\u003c/a\u003e\u003c/p\u003e","title":"Unidbg补环境之补JNI环境","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]